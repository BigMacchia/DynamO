/*  DYNAMO:- Event driven molecular dynamics simulator 
    http://www.marcusbannerman.co.uk/dynamo
    Copyright (C) 2010  Marcus N Campbell Bannerman <m.bannerman@gmail.com>

    This program is free software: you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    version 3 as published by the Free Software Foundation.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
#pragma once

#define STRINGIFY(A) #A
const std::string sphereKernelSource = STRINGIFY(
__kernel void
SphereRenderKernel(const __global float4* positions,
		   __global float * vertexBuffer,
		   const __global float * vertices,
		   const uint nVertex,
		   const uint StartParticle,
		   const uint EndParticle,
		   const int VertexOffset,
		   __global const uint* sortedArray)
{
  //We're trying to coalesce the reads and writes from memory, so we cache
  __local float4 positionCache[WORKGROUP_SIZE];
  __local const float* positionCacheComponents = (__local const float*)positionCache;

  //Iterate on blocks of WORKGROUP_SIZE, with a stride of the global_size
  for (uint id0 = get_group_id(0) * WORKGROUP_SIZE + StartParticle;
       id0 < EndParticle; 
       id0 += get_global_size(0))
    {
      //Load the cache
      uint data_to_read = id0 + get_local_id(0);
      
      //Coalesced read from global mem and conflict-free localsss write
      if (data_to_read < EndParticle)
	{
	  data_to_read = sortedArray[data_to_read];
	  positionCache[get_local_id(0)] = positions[data_to_read];
	}
      
      barrier(CLK_LOCAL_MEM_FENCE);
      
      //Cache is full, now start blitting out verticies
      //Calculate the number of verticie components to do
      uint particles_InCache = min((uint)(WORKGROUP_SIZE), EndParticle - id0);
      uint vertices_components_to_do = 3 * particles_InCache * nVertex;
      
      for (uint vertex_component = get_local_id(0);
	   vertex_component < vertices_components_to_do;
	   vertex_component += get_local_size(0))
	{
	  uint particleID = 4 * (vertex_component / (3 * nVertex)) + (vertex_component % 3);
	  uint vertexID = vertex_component % (3 * nVertex);
	  
	  vertexBuffer[VertexOffset + 3 * nVertex * id0 + vertex_component]
	    = positionCacheComponents[particleID] + vertices[vertexID];
	}

      barrier(CLK_LOCAL_MEM_FENCE);
    }
}

__kernel void
GenerateData(const __global float4* positions,
	     __global float* keys,
	     __global uint* data,
	     float4 camPos, float4 camdir, float4 camup,
	     uint N)
{
  //Need to add the aspect ratio!

  if (get_global_id(0) >= N) return;

  float4 left = cross(camup, camdir);
  
  float4 topPoint = camdir * 0.1f + camup * (0.1f * tan(45.0f * M_PI_F / 180.0f));

  topPoint /= length(topPoint);

  float4 topNorm = cross(left,topPoint);

  float4 bottomPoint = camdir * 0.1f - camup * (0.1f * tan(45.0f * M_PI_F / 180.0f));
  
  bottomPoint /= length(bottomPoint);

  float4 bottomNorm = cross(-left,bottomPoint);

  float4 leftPoint = camdir * 0.1f + left * (0.1f * tan(45.0f * M_PI_F / 180.0f));

  leftPoint /= length(leftPoint);

  float4 leftNorm = cross(-camup,leftPoint);

  float4 rightPoint = camdir * 0.1f - left * (0.1f * tan(45.0f * M_PI_F / 180.0f));

  rightPoint /= length(rightPoint);

  float4 rightNorm = cross(camup,rightPoint);


  float multiplier = 1;

  float4 position = positions[get_global_id(0)];
  position -= camPos;
  position.w = 0;

  multiplier -= 2 * (dot(topNorm, position) < 0);
  multiplier -= 2 * (dot(bottomNorm, position) < 0);
  multiplier -= 2 * (dot(leftNorm, position) < 0);
  multiplier -= 2 * (dot(rightNorm, position) < 0);

  keys[get_global_id(0)] = multiplier * length(position);
  data[get_global_id(0)] = get_global_id(0);
}
);
#undef STRINGIFY
