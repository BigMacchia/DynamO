/*  DYNAMO:- Event driven molecular dynamics simulator 
    http://www.marcusbannerman.co.uk/dynamo
    Copyright (C) 2010  Marcus N Campbell Bannerman <m.bannerman@gmail.com>

    This program is free software: you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    version 3 as published by the Free Software Foundation.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
#pragma once

#define STRINGIFY(A) #A
const std::string sphereKernelSource = STRINGIFY(

typedef struct
{ 
  uint ID;
  float dist;
} SortDataType;

__kernel void
SphereRenderKernel(const __global float * positions,
		   __global float * vertexBuffer,
		   const __global float * vertices,
		   const uint nVertex,
		   const uint StartParticle,
		   const uint EndParticle,
		   const int VertexOffset,
		   __global SortDataType* sortedArray)
{
  //We're trying to coalesce the reads and writes from memory, so we cache
  __local float positionCache[WORKGROUP_SIZE];
  
  //Iterate on blocks of WORKGROUP_SIZE, with a stride of the global_size
  for (uint id0 = get_group_id(0) * WORKGROUP_SIZE + 3*StartParticle;
       id0 < 3 * EndParticle; 
       id0 += get_global_size(0))
    {
      //Load the cache
      uint data_to_read = id0 + get_local_id(0);
      
      //Coalesced read from global mem and conflict-free localsss write
      if (data_to_read < 3 * EndParticle)
	{
	  data_to_read = 3 * sortedArray[data_to_read / 3].ID + (data_to_read % 3);
	  positionCache[get_local_id(0)] = positions[data_to_read];
	}
      
      barrier(CLK_LOCAL_MEM_FENCE);
      
      //Cache is full, now start blitting out verticies
      //Calculate the number of verticie components to do
      uint particles_comp_InCache = min((uint)(WORKGROUP_SIZE), 3*EndParticle - id0);
      uint vertices_components_to_do = particles_comp_InCache * nVertex ;
      
      for (uint vertex_component = get_local_id(0);
	   vertex_component < vertices_components_to_do;
	   vertex_component += get_local_size(0))
	{
	  uint particleID = 3*(vertex_component / (3 * nVertex)) + (vertex_component % 3);
	  uint vertexID = vertex_component % (3*nVertex);
	  
	  vertexBuffer[VertexOffset + nVertex * id0 + vertex_component]
	    = positionCache[particleID] + vertices[vertexID];
	}

      barrier(CLK_LOCAL_MEM_FENCE);
    }
}

__kernel void
GenerateData(const __global float * positions,
	     __global SortDataType* data,
	     float camX, float camY, float camZ,
	     uint N)
{
  if (get_global_id(0) >= N) return;

  float sqdist = positions[3 * get_global_id(0)] - camX;
  sqdist *= sqdist;

  float temp = positions[3 * get_global_id(0) + 1]  - camY;
  sqdist += temp * temp;

  temp = positions[3 * get_global_id(0) + 2]  - camZ;
  sqdist += temp * temp;

  SortDataType entryData;
  entryData.dist = sqdist;
  entryData.ID = get_global_id(0);
  data[get_global_id(0)] = entryData;
}

__kernel void sphereBitonicSort(__global SortDataType* theArray,
				const uint stage, 
				const uint passOfStage,
				const uint realsize,
				const uint direction )
{
    uint threadId = get_global_id(0);
    
    uint pairDistance = 1 << (stage - passOfStage);
    uint blockWidth   = 2 * pairDistance;

    uint leftId = (threadId % pairDistance) 
                   + (threadId / pairDistance) * blockWidth;

    uint rightId = leftId + pairDistance;

    if ((leftId >= realsize) || (rightId >= realsize)) return;
    
    SortDataType leftElement = theArray[leftId];
    SortDataType rightElement = theArray[rightId];
    
    uint sameDirectionBlockWidth = 1 << stage;

    uint sortIncreasing = direction;
    sortIncreasing = ( threadId / sameDirectionBlockWidth ) % 2 == 1 ?
        1 - sortIncreasing : sortIncreasing;

    if ((sortIncreasing && (leftElement.dist > rightElement.dist))
	|| ((!sortIncreasing) && (leftElement.dist < rightElement.dist)))
      {
	SortDataType tempElement = leftElement;
	leftElement = rightElement;
	rightElement = tempElement;
      }

    theArray[leftId]  = leftElement;
    theArray[rightId] = rightElement;
}

//This sorts small blocks that fit into shared memory
__kernel void sphereBitonicLocalSort(__global SortDataType* theArray,
				     uint realsize,
				     uint direction,
				     __local SortDataType* cache)
{
  //__local block must be 2*get_local_size(0) big
  
  //offset the data array pointer
  theArray += 2 * get_group_id(0) * get_local_size(0);

  cache[get_local_id(0)] = theArray[get_local_id(0)];
  cache[2 * get_local_id(0)] = theArray[2 * get_local_id(0)];

  for (uint stageStride = 2; stageStride < 2 * get_local_size(0); stageStride <<=1)
    {
      uint blockDirection = direction ^ (get_local_id(0) & (get_local_size(0) / 2) != 0);
      for (uint passStride = stageStride / 2; passStride > 0; passStride >>=1)
	{
	  barrier(CLK_LOCAL_MEM_FENCE);
	  uint pos = 2 * get_local_id(0) - (get_local_id(0) & (passStride-1));
	  if ((cache[pos].dist < cache[pos + passStride].dist) == blockDirection)
	    {
	      SortDataType tmp = cache[pos];
	      cache[pos] = cache[pos + passStride];
	      cache[pos + passStride] = tmp;
	    }
	}
    }

  for (uint passStride = get_local_size(0); passStride > 0; passStride >>=1)
    {
      barrier(CLK_LOCAL_MEM_FENCE);
      uint pos = 2 * get_local_id(0) - (get_local_id(0) & (passStride-1));
      if ((cache[pos].dist < cache[pos + passStride].dist) == direction)
	{
	  SortDataType tmp = cache[pos];
	  cache[pos] = cache[pos + passStride];
	  cache[pos + passStride] = tmp;
	}
    }

  barrier(CLK_LOCAL_MEM_FENCE);

  theArray[get_local_id(0)] = cache[get_local_id(0)];
  theArray[2 * get_local_id(0)] = cache[2 * get_local_id(0)];
}
);
#undef STRINGIFY
