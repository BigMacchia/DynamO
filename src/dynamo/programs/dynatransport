#!/usr/bin/env python
import os
import math
import xml.etree.ElementTree as ET

#Function to load a (possibly compressed) xml file.
def loadXMLFile(filename):
    #Check if the file is compressed or not, and 
    if (os.path.splitext(filename)[1][1:].strip() == "bz2"):
        import bz2
        f = bz2.BZ2File(filename)
        doc = ET.parse(f)
        f.close()
        return doc
    else:
        return etree.parse(filename)

#Command line argument parsing
from optparse import OptionParser
parser = OptionParser()
parser.add_option("-c", "--cutoff-time", dest="cutofftime", type="float", default=1e300,
                  help="The TIME beyond which data from the correlators are discarded.", metavar="TIME", )
parser.add_option("-s", "--start-time", dest="starttime",
                  help="The amount of TIME to discard data at the start of the correlator.", 
                  type="float", default=0, metavar="TIME")

parser.add_option("-v", "--view-fit", action="store_true", default=False,
                  dest="plot", help="View the fits of the correlators")

(options, datafiles) = parser.parse_args()

#Sort out the data file option
if len(datafiles) is 0:
    print "Need to supply at least one input file!"
    import sys
    sys.exit()

def parseToArray(text):
    data = []
    for line in text.strip().split("\n"):
        dataline = map(float, line.split())
        if (len(dataline) > 1) and (dataline[0] >= options.starttime) and (dataline[0] <= options.cutofftime):
            data.append(dataline)
    return data

def avg(data):
    return sum(data) / len(data)

def stddev(data):
    average = avg(data)
    return avg([(item - average)**2 for item in data])

def fitData(datacolumns, data, title):
    import numpy as np
    from itertools import izip
    xvalues = [line[0] for line in data]
    yvalues = [avg([line[column] for column in datacolumns]) for line in data]
    yerrvalues = [math.sqrt(stddev([line[column] for column in datacolumns])) for line in data]
    fitdata = np.polyfit(xvalues, yvalues, 1, full=True)
    slope = fitdata[0][0]
    intercept = fitdata[0][1]
    SSreg=stddev(np.polyval(fitdata[0],xvalues) - yvalues)
    SStot=stddev(yvalues)
    R2 = 1 - SSreg/SStot
    if (options.plot):
        import matplotlib.pyplot as plt
        plt.title("$"+title+"="+str(slope)+"$ $R^2="+str(R2)+"$")
        plt.errorbar(xvalues, yvalues, yerr=yerrvalues, fmt='x')
        minx = min(xvalues)
        maxx = max(xvalues)
        plt.plot([minx, maxx], [minx * slope + intercept, maxx * slope + intercept])
        plt.show()
    return slope, intercept, R2

shear_viscosity_data = []
bulk_viscosity_data = []
thermalconductivity_data = []
thermaldiffusion_data = {}
mutualdiffusion_data = {}
for filename in datafiles:
    if not os.path.exists(filename):
        print "Could not find the passed datafile! ("+filename+")"
        import sys
        sys.exit()

    #Load the xml file
    XMLDoc = loadXMLFile(filename)
    RootElement=XMLDoc.getroot()

    #Parse all of the transport data (and draw the plots if requested)
    title="Shear\\ viscosity\\ L_{\\eta,\\eta}"
    for xmlelement in RootElement.findall(".//Viscosity/Correlator"):
        shear_viscosity_data.extend([fitData([3, 4, 7], parseToArray(xmlelement.text), title)])

    title="Bulk\\ viscosity\\ L_{\\kappa,\\kappa}"
    for xmlelement in RootElement.findall(".//Viscosity/Correlator"):
        bulk_viscosity_data.extend([fitData([2, 6, 10], parseToArray(xmlelement.text), title)])

    title="Thermal\\ conductivity\\ L_{\\lambda,\\lambda}"
    for xmlelement in RootElement.findall(".//ThermalConductivity/Correlator"):
        thermalconductivity_data.extend([fitData([2, 3, 4], parseToArray(xmlelement.text), title)])

    for xmlelement in RootElement.findall(".//ThermalDiffusion/Correlator"):
        key = xmlelement.attrib["Species"]
        title="Thermal\\ diffusion\\ L_{\\lambda,"+key+"}"
        thermaldiffusion_data.setdefault(key, []).extend([fitData([2, 3, 4], parseToArray(xmlelement.text), title)])

    for xmlelement in RootElement.findall(".//MutualDiffusion/Correlator"):
        key=xmlelement.attrib["Species1"]+","+xmlelement.attrib["Species2"]
        title="Mutual\\ diffusion\\ L_{"+key+"}"
        mutualdiffusion_data.setdefault(key, []).extend([fitData([2, 3, 4], parseToArray(xmlelement.text), title)])


def output(title, correlator_data):
    print title, avg([data[0] for data in correlator_data]), "+-", math.sqrt(stddev([data[0] for data in correlator_data])), "<R>^2=",avg([data[2] for data in correlator_data])

output("ShearViscosityL_{\\eta,\\eta}=",shear_viscosity_data)
output("BulkViscosityL_{\\kappa,\\kappa}=",bulk_viscosity_data)
output("ThermalConductivityL_{\\lambda,\\lambda}=",thermalconductivity_data)

for species, data in thermaldiffusion_data.items():
    output("ThermalDiffusionL_{\\lambda,"+species+"}=",data)

for key, data in mutualdiffusion_data.items():
    output("MutualDiffusionL_{"+key+"}=",data)
