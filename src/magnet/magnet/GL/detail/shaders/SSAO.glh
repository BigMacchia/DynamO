/*    DYNAMO:- Event driven molecular dynamics simulator 
 *    http://www.marcusbannerman.co.uk/dynamo
 *    Copyright (C) 2009  Marcus N Campbell Bannerman <m.bannerman@gmail.com>
 *
 *    This program is free software: you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
 *    version 3 as published by the Free Software Foundation.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

//Simple macro to convert a token to a string
#define STRINGIFY(A) #A

#include <sstream>

namespace magnet {
  namespace GL {
    inline std::string 
    SSAO::vertexShaderSource()
    {
      return 
STRINGIFY( 
void main(void)
{
  gl_Position = ftransform();
  gl_TexCoord[0] = gl_MultiTexCoord0;
}
);
    }
    
    inline std::string 
    SSAO::fragmentShaderSource()
    {
      return 
STRINGIFY(
uniform sampler2D u_Texture0;
uniform sampler2D u_Texture1;
uniform sampler2D u_Texture2;
uniform sampler2D rnm;
uniform float radius;
uniform float totStrength;
uniform float strength;
uniform float offset;
uniform float falloff;
const float invSamples = 1.0 / 10.0;

float LinearizeDepth(float zoverw)
{
	float n = 0.001;
	float f = 100.0;
	
	return(2.0 * n) / (f + n - zoverw * (f - n));	
}

//uniform sampler2D rnm;
//varying vec2 uv;

void main(void)
{
  // these are the random vectors inside a unit sphere
  vec3 pSphere[10] = vec3[10](vec3(-0.010735935, 0.01647018, 0.0062425877),
			      vec3(-0.06533369, 0.3647007, -0.13746321),
			      vec3(-0.6539235, -0.016726388, -0.53000957),
			      vec3(0.40958285, 0.0052428036, -0.5591124),
			      vec3(-0.1465366, 0.09899267, 0.15571679),
			      vec3(-0.44122112, -0.5458797, 0.04912532),
			      vec3(0.03755566, -0.10961345, -0.33040273),
			      vec3(0.019100213, 0.29652783, 0.066237666),
			      vec3(0.8765323, 0.011236004, 0.28265962),
			      vec3(0.29264435, -0.40794238, 0.15964167));
  
//  vec3 pSphere[16] = vec3[16](vec3(0.53812504, 0.18565957, -0.43192),
//			      vec3(0.13790712, 0.24864247, 0.44301823),
//			      vec3(0.33715037, 0.56794053, -0.005789503),
//			      vec3(-0.6999805, -0.04511441, -0.0019965635),
//			      vec3(0.06896307, -0.15983082, -0.85477847),
//			      vec3(0.056099437, 0.006954967, -0.1843352),
//			      vec3(-0.014653638, 0.14027752, 0.0762037),
//			      vec3(0.010019933, -0.1924225, -0.034443386),
//			      vec3(-0.35775623, -0.5301969, -0.43581226),
//			      vec3(-0.3169221, 0.106360726, 0.015860917),
//			      vec3(0.010350345, -0.58698344, 0.0046293875),
//			      vec3(-0.08972908, -0.49408212, 0.3287904),
//			      vec3(0.7119986, -0.0154690035, -0.09183723),
//			      vec3(-0.053382345, 0.059675813, -0.5411899),
//			      vec3(0.035267662, -0.063188605, 0.54602677),
//			      vec3(-0.47761092, 0.2847911, -0.0271716));
  // grab a normal for reflecting the sample rays later on
  vec3 fres = normalize((texture2D(rnm, gl_TexCoord[0].st * offset).xyz * 2.0) - vec3(1.0));
  
  vec4 currentPixelSample = texture2D(u_Texture1, gl_TexCoord[0].st);
  
  //Depth definition
  float currentPixelDepth = LinearizeDepth(texture2D(u_Texture2, gl_TexCoord[0].st).r) * 20;
  
  // current fragment coords in screen space
  vec3 ep = vec3(gl_TexCoord[0].st, currentPixelDepth);
  // get the normal of current fragment
  vec3 norm = normalize(2.0*currentPixelSample.xyz - 1.0);
  
  float bl = 0.0;
  // adjust for the depth ( not shure if this is good..)
  float radD = radius / currentPixelDepth;
  
  //vec3 ray, se, occNorm;
  float occluderDepth;
  for(int i = 0; i < 10; ++i)
    {
      // get a vector (randomized inside of a sphere with radius 1.0) from a texture and reflect it
      vec3 ray = radD*reflect(pSphere[i],fres);
      
      // get the depth of the occluder fragment
      vec2 occluderLoc = ep.xy + sign(dot(ray,norm) )*ray.xy;
      vec4 occluderFragment = texture2D(u_Texture1, occluderLoc);

      float occluderDepth = LinearizeDepth(texture2D(u_Texture2, occluderLoc).r) * 20;

      // if depthDifference is negative = occluder is behind current fragment
      float depthDifference = currentPixelDepth - occluderDepth;
      
      vec3 occluderNorm = normalize(occluderFragment.xyz * 2.0 - 1.0);
      float occluderDot = -dot(occluderNorm,norm);

      bl += step(0, occluderDot) * occluderDot * step(0, depthDifference) 
	* (1.0 - smoothstep(0, strength, depthDifference));
      ;

    }

  //Store the pixel depth too for the blur stage
  gl_FragColor.r = clamp(1.0-totStrength*bl*invSamples, 0, 1);
  
  //gl_FragColor.r = currentPixelDepth;
  //gl_FragColor.r = currentPixelSample.a;
  //gl_FragColor.a = currentPixelDepth;
}
);
    }
  }
}
