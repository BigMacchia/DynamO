/*    DYNAMO:- Event driven molecular dynamics simulator 
 *    http://www.marcusbannerman.co.uk/dynamo
 *    Copyright (C) 2009  Marcus N Campbell Bannerman <m.bannerman@gmail.com>
 *
 *    This program is free software: you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
 *    version 3 as published by the Free Software Foundation.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

//Simple macro to convert a token to a string
#define STRINGIFY(A) #A

namespace magnet {
  namespace GL {
    inline std::string 
    shadowShader::vertexShaderSource()
    {
      return
STRINGIFY( 
// Used for shadow lookup
varying vec4 ShadowCoord;
varying vec3 lightVec;
varying vec3 normal;
varying vec3 viewVec;
uniform int shadowMapping;

void main()
{
  if (shadowMapping == 1)
    ShadowCoord= gl_TextureMatrix[7] * gl_ModelViewMatrix * gl_Vertex;

  gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;
  
  normal = normalize(gl_NormalMatrix * gl_Normal);

  lightVec = normalize(vec3(gl_LightSource[0].position - gl_ModelViewMatrix * gl_Vertex));

  gl_FrontColor = gl_Color;

  viewVec = vec3(gl_ModelViewMatrix * gl_Vertex);
}
);
    }

    inline std::string 
    shadowShader::fragmentShaderSource()
    {
      return
STRINGIFY( 
uniform sampler2DShadow ShadowMap;
uniform int shadowMapping;
uniform float shadowIntensity;
varying vec4 ShadowCoord;
varying vec3 lightVec;
varying vec3 normal;
varying vec3 viewVec;

void main()
{
  float shadow = 0 ;
  
  const int steps = 3;
  const float step = 0.001f;
  const float stepoffset = (steps - 1.0f) * 0.5f;

  float lightNormDot = dot(normalize(normal), normalize(lightVec));
  
  if (shadowMapping == 1)
    {
      if (ShadowCoord.w > 1.0)
	for (int x = 0; x < 3; ++x)
	  for (int y = 0; y < 3; ++y)
	    //Replace textureProj with shadow2DProj to make it work on old versions of GLSL
	    shadow += textureProj(ShadowMap, ShadowCoord 
				  + vec4((-stepoffset + x) * step * ShadowCoord.w, 
					 (-stepoffset + y) * step * ShadowCoord.w, 
					 0,//-0.00002,
					 0)).r;
  
      shadow /= steps * steps;

      //Now set a minimum on the shadow term depending on if the
      //surface is pointing away from the light source
      if (lightNormDot < 0)
	shadow = clamp(shadow, 0.0, 1+2*lightNormDot);
    }
  else
    shadow = 1.0;
  
  float DiffuseTerm = 0.5 * lightNormDot + 0.5;
 
  float specular = shadow * max(dot(reflect(normalize(lightVec), normalize(normal)), 
				    normalize(viewVec)), 
				0.0);
  
  specular *= specular * specular * specular;

  gl_FragColor =  gl_Color * (((1 + shadowIntensity * (shadow - 1)) * DiffuseTerm //Diffuse + Shadow lighting
			       ) * vec4(1.0,1.0,1.0,0) //Conversion to white channel
			      + vec4(0,0,0,1) //The alpha channel
			      )
    + 0.2 * specular * vec4(1.0,1.0,1.0,0); //Specular lighting is pure white
;
}
);
    }
  }
}
