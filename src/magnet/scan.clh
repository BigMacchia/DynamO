/*  DYNAMO:- Event driven molecular dynamics simulator 
    http://www.marcusbannerman.co.uk/dynamo
    Copyright (C) 2010  Marcus N Campbell Bannerman <m.bannerman@gmail.com>

    This program is free software: you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    version 3 as published by the Free Software Foundation.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#pragma once

#define STRINGIFY(A) #A
const std::string sortKernelSource = STRINGIFY(
#define WORKGROUP_SIZE 256
#define scantype uint

__kernel __attribute__((reqd_work_group_size(WORKGROUP_SIZE, 1, 1)))
void prescan(__global scantype *g_idata, __global scantype *g_odata, uint n)
{
  __local scantype temp[2 * WORKGROUP_SIZE]; 

  size_t memoffset = 2 * WORKGROUP_SIZE * get_group_id(0);

  //Do the offsets
  g_idata += memoffset;
  g_odata += memoffset;

  // load input into shared memory
  if ((memoffset + 2*get_local_id(0)) < n)
    temp[2 * get_local_id(0)] =  g_idata[2 * get_local_id(0)]; 
  else
    temp[2 * get_local_id(0)] =  0;
  
  if ((memoffset + 2 * get_local_id(0) + 1) < n)
    temp[2 * get_local_id(0)+1] = g_idata[2 * get_local_id(0) + 1];
  else
    temp[2 * get_local_id(0)+1] = 0;

  // build sum in place up the tree
  int stride = 1;  
  for (int d = WORKGROUP_SIZE; d > 0; d >>= 1) 
    {
      barrier(CLK_LOCAL_MEM_FENCE);
      
      if (get_local_id(0) < d)
	{
	  int ai = stride*(2*get_local_id(0)+1)-1;
	  temp[ai + stride] += temp[ai];
	}
      stride *= 2;
    }

  // clear the last element
  if (get_local_id(0) == 0) { temp[2 * WORKGROUP_SIZE - 1] = 0; } 

  // traverse down tree & build scan
  for (int d = 1; d < 2 * WORKGROUP_SIZE; d *= 2)
    {
      stride >>= 1;
      barrier(CLK_LOCAL_MEM_FENCE);
      if (get_local_id(0) < d)
	{
	  int ai = stride*(2*get_local_id(0)+1)-1;
	  scantype t = temp[ai];
	  temp[ai] = temp[ai + stride];
	  temp[ai+stride] += t;
	}
    }

  barrier(CLK_LOCAL_MEM_FENCE);

  // write results to device memory
  if ((memoffset + 2 * get_local_id(0)) < n)
      g_odata[2*get_local_id(0)] = temp[2*get_local_id(0)]; 

  if ((memoffset + 2 * get_local_id(0) + 1) < n)
      g_odata[2 * get_local_id(0) + 1] = temp[2*get_local_id(0)+1];
}
);
#undef STRINGIFY
